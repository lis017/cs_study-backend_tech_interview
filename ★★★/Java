사용한 java, jdk, springboot 버전?
-> java: 21 
/ jdk: 21
/ Spring Boot 3.x 버전

해당버전 왜썼죠?
-> java(+jdk):
LTS(Long Term Support) 버전이라 장기 운영에 안정적
Spring Boot 3.x가 Java 17 이상을 요구해서 호환성 문제 없음
또한 최신 버전이라 전반적인 성능 개선과 유지보수 측면에서 유리하다고 판단했습니다.”
-> springboot:
“Spring Boot 3.4는 Jakarta 기반으로 전환된 이후 안정화가 잘 된 버전이고,
JDK 21과의 호환성을 고려해 선택했습니다.”

왜 java 17안쓰고 21썼죠?
-> “회사 환경이나 레거시 제약이 있다면 JDK 17도 충분히 적합하다고 생각하고 있고,
프로젝트 요구사항과 조직 표준에 맞춰 버전을 선택하는 게 중요하다고 생각합니다.”
->“JDK 21도 LTS 버전이라 안정성 측면에서 17과 큰 차이가 없다고 판단했습니다.
다만 더 최신 LTS인 21을 사용하면 성능 개선과 향후 확장성 측면에서 이점이 있어
Spring Boot 3.4와의 공식 호환 범위 내에서 선택했습니다.”
-----------------------
객체지향 4원칙
->객체지향의 4원칙은 캡슐화, 상속, 다형성, 추상화입니다.
->캡슐화는 객체의 내부 구현을 숨기고 필요한 인터페이스만 노출하여 변경에 강한 구조를 만드는 것이고,
상속은 기존 클래스를 재사용하여 공통 로직을 확장하는 방식입니다.
다형성은 같은 인터페이스를 통해 서로 다른 구현을 유연하게 사용하는 개념이며,
추상화는 공통적인 개념만 뽑아 상위 타입으로 정의하여 복잡도를 낮추는 원칙입니다.
(
ex. service에서 repository.search를 호출해서쓰지만, 실제search구현체는 repositoryImpl에 있고, 그 impl함수는 customrepository를
repository에서 extends하기때문에 쓸수있으며, service는 구현체.(동작 어떻게하는지)를 모름. 이것이 추상화.
)
//짧게-> Service는 “무엇을 한다(search)”만 알고, “어떻게 구현했는지(RepositoryImpl)”는 모르게 숨긴 것 = 추상화
->특히 실무에서는 다형성과 캡슐화가 중요하다고 생각합니다.
예를 들어 스프링에서는 인터페이스 기반으로 구현체를 분리하고,
다형성을 통해 구현체를 교체하더라도 비즈니스 로직의 변경 없이 확장할 수 있습니다.
-----------------------
(프레임워크) 스프링 filter와 interceptor의 차이점에대해 기술하세요.
(간단)
->“Filter는 서블릿 컨테이너 레벨에서 동작하여 요청을 스프링으로 넘기기 전에 공통 처리를 하고,
Interceptor는 스프링 MVC 레벨에서 Controller 실행 전후의 흐름을 제어하는 역할을 합니다.”
->“보안이나 인코딩 같은 전역 처리는 Filter가 적합하고, 로그인 체크나 권한 검사는 Interceptor가 더 적합합니다.”
(심화)
->Filter: 
(정의)서블릿 컨테이너(Tomcat) 에서 동작
(특징)요청/응답 자체를 전처리하는 용도
  스프링 진입 전/후 요청을 가로챔
  기본적으로 spring bean아님(but. 설정하면 가능)
(사용처)인코딩 처리
  인증/인가 (JWT 토큰 검증)
  로깅, XSS 방어
(사용경험)
  -CSRF토큰 검증을 Controller진입전 요청을 가로채 검증. 인증관련보안책임을 Filter계층으로 분리하여 유지보수성향상
  -로그인인증처리, 로그아웃처리(로그아웃 요청 가로채, 세션 무효화 수행)
  -“로그인, 로그아웃, CSRF 방어를 Controller가 아니라 Spring Security의 Filter 계층에서 처리하여 보안 책임을 명확히 분리했습니다.”
Interceptor: 
(정의)DispatcherServlet과 Controller 사이에서 요청·응답을 가로채 공통 로직을 처리하는 컴포넌트입니다.
스프링 MVC에서 제공
Controller 실행 전/후 요청을 가로챔
(특징)“인터셉터는 스프링 빈으로 등록해서 사용하는 컴포넌트다”
//컴포넌트: 특정 기능을 수행하는 독립적인 구성 단위 / ex.) @Component, @Service, @Repository, @Controller
(사용처)로그인 체크
  권한 검사
  Controller 공통 로직
  요청/응답 로깅
->(흐름) Client → Filter → DispatcherServlet → Interceptor → Controller

DispatcherServlet은?  //(Servlet의 한 종류)
->“DispatcherServlet은 스프링 MVC에서 모든 요청을 중앙에서 받아 적절한 컨트롤러로 분배하고 응답까지 관리하는 프론트 컨트롤러입니다.”
->(심화)DispatcherServlet이 어떤 Controller(= Handler) 가 처리할지 결정. 그 Controller에게 요청 처리 책임을 위임

(안봐도됨)
서블릿(Servlet)이란?
->(간단)서블릿은 HTTP 요청을 처리하기 위한 자바 웹 컴포넌트이며, 톰캣 같은 서블릿 컨테이너에서 실행된다.
-> 웹 요청(Request)을 받아서 비즈니스 로직을 처리하고 응답(Response)을 만들어주는 자바 프로그램입니다.
------------------------
컴파일단계와 런타임단계란?    //프로그래밍언어 공통개념이지만 java에 맞춰서 적어봄
->컴파일 단계는 소스 코드를 실행 가능한 형태로 바꾸는 과정이고, 
//★오류를 미리 걸러주는 단계
//java->class
런타임은 그 결과물이 실제로 실행되면서 동작하는 단계입니다. 실행은 런타임에 포함됩니다.
//★실제 비즈니스 로직이 동작하며 예외가 발생하는 단계
//실행은 런타임속에 포함된것.
-----------------------
자식클래스에서 오버라이딩했는데
부모 함수 쓰려면?
->super.함수명()
//☆java기능 쓴것이다
-------------------------
추상클래스와 인터페이스 설명해주세요.
->추상클래스(Abstract Class): 공통 기능과 상태를 공유하기 위한 상위 클래스
“기본 기능을 제공하면서, 자식 클래스가 확장하도록 설계할 때 사용합니다.”
(목적)‘상속을 통한 기능 확장’,
->인터페이스 (Interface): 인터페이스는 구현 없이 규약(계약)만 정의해서, 클래스 간 결합도를 낮추기 위한 수단입니다.
“어떤 기능을 반드시 제공해야 한다는 약속을 정의합니다.”
(목적)‘구현체 교체와 다형성 확보’
“예를 들어 결제 시스템에서 Payment는 인터페이스로 두고, KakaoPay, CardPay 같은 구현체를 자유롭게 교체하도록 설계합니다.”
