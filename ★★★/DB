트랜잭션과 데드락의 관계
-> 트랜잭션이 데이터 정합성을 보장하기 위해 보통 Row단위로 락을 사용하고,      
여러 트랜잭션이 서로가 가진 락을 기다리면 데드락이 발생합니다.
//고객테이블 / 컬럼(필드)는 이름. 아이디등일때 / (민혁, lis)이게 row(Record)
//락은 db작업(수정)전에 정합성을위해, row를 잠구는것. / 잠구고 수정하고 락 품
//데드락은 동시성 문제
->(심화)
대부분 DB는 데드락을 자동 감지
감지 시 한 트랜잭션을 강제 롤백해서 풀어줌
-개발자는
락 순서 통일                                      //락을 잡는 순서가 꼬이면 서로가 가진 락을 기다리면서 데드락이 발생할 수 있습니다.”
트랜잭션 범위 최소화
불필요한 동시 수정 제거
 이런 걸로 예방
//deadlock -> 락때문에 죽은것과같은상태.
//락 자체는 정상적인 동시성 제어 수단
----------------------------
MyBatis 보충설명
->JPA의 대체제가 아니라, ORM이 불리한 조회 영역을 보완하는 도구입니다.”
-----------------------------
SQL Injection이란?
->사용자 입력값에 SQL을 섞어 넣어서, DB 쿼리를 조작하는 공격
ex)SELECT * FROM user WHERE id = '입력값'
이 입력값에 ' OR 1=1 -- 이거넣으면 
항상 참이 되어 모든 데이터 조회 / 로그인 우회가 됩니다.

SQL Injection 방어방법
->ORDER BY, 컬럼명은 enum 화이트리스트(정석, 나도 이걸로할듯)
