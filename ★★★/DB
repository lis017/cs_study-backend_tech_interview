영속성 컨텍스트
->DB 조회를 가능하게 하는 권한이나 입구가 아니라,
엔티티를 캐시처럼 보관하면서 상태를 추적하는 메모리 컨테이너이고,
트랜잭션이 끝나면 컨텍스트 자체가 종료되어 메모리에서 사라집니다.

세션(영속성 컨텍스트)는 대부분 트랜잭션 시작에 열리고 트랜잭션 종료에 닫힘.
그 영속성 컨텍스트가 열려있을때 db조회(LAZY초기화등)이 가능함
//osiv설정을 키면 트랜잭션 끝나도 영속성컨텍스트 살아있지만 성능문제(실무에선 킬수도 있음)

->1차 cache역할.
트랜잭션 열린동안 같은pk접근시 db접근안하고 영속성컨텍스트가 반환
---------
LAZY초기화란
-> 참조인 LAZY의 실제값을 DB에서 조회해서 메모리에 올리는것.

Lazy 초기화 어떻게했는데
-> 객체를 List로 받아서 
 list.size(); 같은 컬렉션 접근 메서드를 호출하면 JPA가 DB에 쿼리를 날려서 실제 데이터를 가져오므로, 명시적 Lazy 초기화
---------
트랜잭션과 데드락의 관계
-> 트랜잭션이 데이터 정합성을 보장하기 위해 보통 Row단위로 락을 사용하고,      
여러 트랜잭션이 서로가 가진 락을 기다리면 데드락이 발생합니다.
//고객테이블 / 컬럼(필드)는 이름. 아이디등일때 / (민혁, lis)이게 row(Record)
//락은 db작업(수정)전에 정합성을위해, row를 잠구는것. / 잠구고 수정하고 락 품
//데드락은 동시성 문제
->(심화)
대부분 DB는 데드락을 자동 감지
감지 시 한 트랜잭션을 강제 롤백해서 풀어줌
-개발자는
락 순서 통일                                      //락을 잡는 순서가 꼬이면 서로가 가진 락을 기다리면서 데드락이 발생할 수 있습니다.”
트랜잭션 범위 최소화
불필요한 동시 수정 제거
 이런 걸로 예방
//deadlock -> 락때문에 죽은것과같은상태.
//락 자체는 정상적인 동시성 제어 수단
----------------------------
MyBatis 보충설명
->JPA의 대체제가 아니라, ORM이 불리한 조회 영역을 보완하는 도구입니다.”
-----------------------------
SQL Injection이란?
->사용자 입력값에 SQL을 섞어 넣어서, DB 쿼리를 조작하는 공격
ex)SELECT * FROM user WHERE id = '입력값'
이 입력값에 ' OR 1=1 -- 이거넣으면 
항상 참이 되어 모든 데이터 조회 / 로그인 우회가 됩니다.

SQL Injection 방어방법
->ORDER BY, 컬럼명은 enum 화이트리스트(정석, 나도 이걸로할듯)
//화이트리스트: 허용된값만 들어옴 / enum: 뭐 허용할지 정하는놈 / ORDER BY는 “결과를 어떤 컬럼 기준으로, 오름/내림차순 정렬할지”를 정합니다.
