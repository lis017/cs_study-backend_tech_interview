왜 (로그인,권한체크등) Interceptor를 보통 쓰는곳에 Spring Security Filter Chain를 사용했죠?
->“인증·인가처럼 보안이 핵심인 영역은
Interceptor보다 Spring Security의 필터 체인이 더 적합하다고 판단했습니다.”
->Interceptor는 단순 제어용,
Security는 인증·인가 전용 프레임워크
->결정적이유
1. 인증·인가 책임을 프레임워크에 위임(비밀번호 비교, 세선생성 등)
2. Filter 단계에서 처리 (Interceptor보다 앞단)(보안은 최대한 앞에서 막는 게 정석)
3.선언적 권한 제어 가능(EX.sec:authorize="hasAuthority('regular')")
★->“Interceptor는 인증이 끝난 이후의 요청 흐름 제어에는 적합하지만,
인증 자체를 책임지기에는 기능과 안정성 면에서 한계가 있습니다.”
★로그인/ 권한(Role) /화면 분기 /세션 관리 /보안 등 기능 만드는데, 이건 Interceptor 범위 초과 ->그래서 Security 선택 = 설계 판단 능력
//filter는 java / interceptor는 spring쪽이다. 대충

--------------------------------
Spring AOP란?
->AOP는 공통 로직을 분리해서 필요한 지점에 자동으로 끼워 넣는 기술입니다.
->Spring에서는 이를 프록시 기반으로 구현
->“로깅, 트랜잭션, 보안 같은 공통 기능을 코드 수정 없이 적용할 수 있게 해줍니다.”
(장점)가독성과 유지보수성
(구조)언제/ 어디에 /어떤공통로직. 의 구조로 사용
ex) before / 어디메서드에 / 트랜잭션
(동작흐름)
클라이언트가 메서드 호출
프록시 객체가 먼저 가로챔
공통 로직 실행
실제 대상 메서드 실행
공통 로직 마무리

AOP와 (Filter/Interxeptor)의 차이
메서드단위 / HTTP요청
비즈니스공통로직 / 인증,세션
서비스로직레벨(스프링내부) / 서블릿컨테이너(웹요청레벨)
------------
Dispatvher Servlet은 
->프론트 컨트롤러이다.
-> 요청을 받아 HandlerMapping·Adapter로 컨트롤러를 실행하고, 결과를 View로 렌더링까지 연결하는 프론트 컨트롤러

Dispatcher Servlet이 어떤 컨트롤러나 핸들러에 요청보낼지 정하는게 아니라
Handller Mapping이 결정하고
Dispatcher Servlet은 mapping와 adapter(어댑터)를 조율하는 조율자.(orchestrator)(오케스트레이터)
