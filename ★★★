@Async가 뭐죠?
-> Spring에서 메서드를 별도의 스레드에서 비동기로 실행하여, 
호출한 스레드를 즉시 반환시키는 기능(동기 호출의 흐름을 반환하고, Async부분은 비동기로 천천히 진행한다)
->(심화)
Spring의 @Async는 프록시 기반 AOP로 메서드 호출을 가로채고, 
실제실행은 ThreadPool에서 관리되는 별도 스레드에서 처리됩니다.
따라서 내부 메서드 호출에서는 동작x

@Async 왜쓰죠?
-> 시간 오래 걸리지만 즉시 결과가 필요없는 작업에 사용
 .사용자 요청은 빠르게 응답
 .실제 작업은 백그라운드 처리

@Async 단점은?
-> 예외 전파와 트랜잭션 관리가 복잡해질 수 있음

@Async사용시 주의점
-> ThreadPool설정을 하지않으면 서버안정성에 문제
-> 실무에선 ThreadPoolTaskExecutor 필수
(안하면 쓰레드 무한증식 -> 서버터짐)
(쓰레드 개수와 큐를 제한하는것.)
@주의점2
-> 기본 트랜잭션된 함수내에서 Async쓰면 async함수는 트랜잭션 포함안됨 / async어노테이션 바로위or아래에 @Tracsactional 써야 적용됨
@주의점3
-> 예외발생시
@Async는 예외가 호출부로 전파되지 않기 때문에
AsyncUncaughtExceptionHandler로 로그·알림을 보장하거나,
중요 로직은 CompletableFuture로 예외를 명시적으로 처리해야함

같은 클래스 내부에서 @Async 호출하면?
-> X. 비동기 안됨.
->이유: 프록시 안거침 / 자기자신호출(self-invocation)
(꼭 다른클래스에서 호출해야함(bean간 호출))
(프록시란? : 실제 객체 앞에 끼워진 '대리객체'
/ Spring은 이 프록시를 통해서만 @Async, @Transactional, @Cacheable 같은 기능을 적용합니다.)

@Async 반환 타입
-> CompletableFuture<T> / 추천  (T는 String등 타입)
void / 결과 못 받음

비동기 할떄, 왜 @Async썼죠?
->해당 작업은 요청 흐름과 강하게 결합될 필요가 없는 후처리 작업이었고,
구현 복잡도를 낮추면서 **응답 지연을 줄이기 위해 @Async를 선택했습니다.
대규모 I/O나 고부하 환경이었다면 WebClient나 메시지 큐를 고려했을 것입니다.

비동기 처리방법 어떤것들있죠?
-> @Async (간단한 백그라운드 작업)
CompletableFuture (비동기 + 결과 처리)
WebClient(대규모 외부 API 호출)
메시지 큐 (Kafka)(대규모 트래픽 이벤트)(데이터 모으기)
@Scheduled (스케줄링)(통계 집계 / 로그 정리)
Spring Batch(수만~수백만 건 데이터 처리)(데이터 처리)

webclient썼으면서, 왜 굳이 Async로? 재사용하면 안됐나?
-> WebClient쓰면 upsert로직은 비동기안됨.
-> 업무처리 분리 개념은 Async로 충분. / 대용량되면 kafka / batch로.

Thread 안전성 문제가 뭐죠?
->여러 스레드가 동시에 같은 자원(변수, 객체, DB 상태 등)에 접근할 때
실행 순서에 따라 결과가 달라지거나 데이터 불일치가 발생하는 문제

Thread 안전성 문제는 해결했는가?
->1.@Async 메서드를 무상태(stateless)로 유지하고,            //무상태(stateless): 비동기 메서드 내부에 “공유되는 상태값”을 두지 않았다는 뜻
파라미터 기반으로만 동작하도록 구성하여
스레드 간 상태 공유로 인한 문제는 발생하지 않도록 설계
->2.애플리케이션 레벨에서 공유 객체를 직접 수정하지 않고,
데이터 변경은 DB에 위임하는 구조로 설계해
기본적인 JVM레벨의 쓰레드 안전성은 확보한 상태
(ex)repository.함수 이걸로 데이터 변환했던것)
(공유객체 수정하지않았다. 뜻은?
-> 클래스 필드 안쓰고 매개변수 쓰고 데이터변경은 repository를 사용->db위임)
(db에 위임하면 왜 안전?
-> db가 원래 동시에 여러 요청이와도 깨지지않게 설계
+ 충돌시 db가 락.롤백.차단 수행
(향후)동시에 동일 데이터에 대한 upsert가 발생할 수 있는 경우를 대비해서는,
향후 unique constraint나 @Transactional 기반의 정합성 보완이 필요하다고 인지하고 있습니다.


--------
외부 API가 뭐죠?
-> 내가 만든 서버가 아닌 다른회사·서비스가 제공하는 기능·데이터를 HTTP요청으로 사용하는것
-> 예시: 공휴일 / 결제(카카오페이 등) / 로그인(카카오 소셜로그인) / 지도(카카오맵) API

외부 API 왜 썼죠? 왜 쓰죠?
->외부API사용경험 필요해서
-> 직접 구현하기 어려운 기능을 신뢰성 있게 재사용
최신 데이터(결제 상태, 공휴일 등)를 외부에서 제공받기 위함

외부API사용시 백엔드로서 생각(걱정, 고려)해볼점
->네트워크 지연·실패 가능성 있음
->타임아웃, 재시도, 예외 처리 필요
동기 호출 시 성능 영향 → @Async, 캐싱 등으로 보완
{
타임아웃: 외부 API가 응답을 안 주면 스레드가 계속 대기 → 서버 장애 / 몇초까지 기다리고 신호안오면 실패처리 / 지연대응
재시도: 몇초있다가 몇번만 재시도 / 무한x / 실패대응
예외처리: 캐시데이터 사용 / 현재사용불가 응답 / 기본값 반환 / 장애전파 차단
  (캐시는 단순한 성능 최적화 수단이 아니라,
  **외부 의존성 장애 시에도 서비스를 유지하기 위한 회복 전략(fallback)**으로 사용했습니다.)
  (하루나 한시간정도 데이터가 캐시에 남아있고, 일정시간 재사용 하는것
}

본인이 외부API사용하며 그런 단점에 대비한것이 있는가?
->외부 API 지연이 사용자 응답에 영향 주지 않도록 최근데이터 응답후, @Async를 써서 비동기 백그라운드 upsert 처리 / 응답지연회피

log.info가 운영에서 왜 도움됨?
-> 운영환경에서 print못봄.
로그는 볼수있음
과정 하나하나 log를 남기면 
그걸 기반으로 원인파악 빠르게 가능.
->무중단 운영시에도 파악가능
->운영 가시성(Observability)을 확보하는 핵심수단
