@Async가 뭐죠?
-> Spring에서 메서드를 별도의 스레드에서 비동기로 실행하여, 
호출한 스레드를 즉시 반환시키는 기능(동기 호출의 흐름을 반환하고, Async부분은 비동기로 천천히 진행한다)
->(심화)
Spring의 @Async는 프록시 기반 AOP로 메서드 호출을 가로채고, 
실제실행은 ThreadPool에서 관리되는 별도 스레드에서 처리됩니다.
따라서 내부 메서드 호출에서는 동작x

@Async 왜쓰죠?
-> 시간 오래 걸리지만 즉시 결과가 필요없는 작업에 사용
 .사용자 요청은 빠르게 응답
 .실제 작업은 백그라운드 처리

@Async 단점은?
-> 예외 전파와 트랜잭션 관리가 복잡해질 수 있음

@Async사용시 주의점
-> ThreadPool설정을 하지않으면 서버안정성에 문제
-> 실무에선 ThreadPoolTaskExecutor 필수
(안하면 쓰레드 무한증식 -> 서버터짐)
(쓰레드 개수와 큐를 제한하는것.)
@주의점2
-> 기본 트랜잭션된 함수내에서 Async쓰면 async함수는 트랜잭션 포함안됨 / async어노테이션 바로위or아래에 @Tracsactional 써야 적용됨
@주의점3
-> 예외발생시
@Async는 예외가 호출부로 전파되지 않기 때문에
AsyncUncaughtExceptionHandler로 로그·알림을 보장하거나,
중요 로직은 CompletableFuture로 예외를 명시적으로 처리해야함

같은 클래스 내부에서 @Async 호출하면?
-> X. 비동기 안됨.
->이유: 프록시 안거침 / 자기자신호출(self-invocation)
(꼭 다른클래스에서 호출해야함(bean간 호출))
(프록시란? : 실제 객체 앞에 끼워진 '대리객체'
/ Spring은 이 프록시를 통해서만 @Async, @Transactional, @Cacheable 같은 기능을 적용합니다.)

@Async 반환 타입
-> CompletableFuture<T> / 추천  (T는 String등 타입)
void / 결과 못 받음

비동기 할떄, 왜 @Async썼죠?
->해당 작업은 요청 흐름과 강하게 결합될 필요가 없는 후처리 작업이었고,
구현 복잡도를 낮추면서 **응답 지연을 줄이기 위해 @Async를 선택했습니다.
대규모 I/O나 고부하 환경이었다면 WebClient나 메시지 큐를 고려했을 것입니다.

비동기 처리방법 어떤것들있죠?
-> @Async (간단한 백그라운드 작업)
CompletableFuture (비동기 + 결과 처리)
WebClient(대규모 외부 API 호출)
메시지 큐 (Kafka)(대규모 트래픽 이벤트)(데이터 모으기)
@Scheduled (스케줄링)(통계 집계 / 로그 정리)
Spring Batch(수만~수백만 건 데이터 처리)(데이터 처리)

webclient썼으면서, 왜 굳이 Async로? 재사용하면 안됐나?
-> WebClient쓰면 upsert로직은 비동기안됨.
-> 업무처리 분리 개념은 Async로 충분. / 대용량되면 kafka / batch로.

Thread 안전성 문제가 뭐죠?
->여러 스레드가 동시에 같은 자원(변수, 객체, DB 상태 등)에 접근할 때
실행 순서에 따라 결과가 달라지거나 데이터 불일치가 발생하는 문제

Thread 안전성 문제는 해결했는가?
->1.@Async 메서드를 무상태(stateless)로 유지하고,            //무상태(stateless): 비동기 메서드 내부에 “공유되는 상태값”을 두지 않았다는 뜻
파라미터 기반으로만 동작하도록 구성하여
스레드 간 상태 공유로 인한 문제는 발생하지 않도록 설계
->2.애플리케이션 레벨에서 공유 객체를 직접 수정하지 않고,
데이터 변경은 DB에 위임하는 구조로 설계해
기본적인 JVM레벨의 쓰레드 안전성은 확보한 상태
(ex)repository.함수 이걸로 데이터 변환했던것)
(공유객체 수정하지않았다. 뜻은?
-> 클래스 필드 안쓰고 매개변수 쓰고 데이터변경은 repository를 사용->db위임)
(db에 위임하면 왜 안전?
-> db가 원래 동시에 여러 요청이와도 깨지지않게 설계
+ 충돌시 db가 락.롤백.차단 수행)
(향후)동시에 동일 데이터에 대한 upsert가 발생할 수 있는 경우를 대비해서는,
향후 unique constraint나 @Transactional 기반의 정합성 보완이 필요하다고 인지하고 있습니다.
(unique constraint: db에서 데이터 강제 중복금지 / @Transactional: insert후 update하는데 insert하고, update전에 예외발생시 정합성 깨짐. 그걸 보완)
-------------------------------
log.info가 운영에서 왜 도움됨?
-> 운영환경에서 print못봄.
로그는 볼수있음
과정 하나하나 log를 남기면 
그걸 기반으로 원인파악 빠르게 가능.
->무중단 운영시에도 파악가능
->운영 가시성(Observability)을 확보하는 핵심수단
------------------------------------------------
QueryDSL이 뭐죠?
->자바 코드로 SQL을 타입 세이프하게 작성할 수 있도록 도와주는 쿼리 빌더 라이브러리
->(심화) QueryDSL은 타입 세이프한 자바 코드 기반 쿼리 작성으로, 복잡한 동적 조회를 안전하게 처리하기 위한 기술

QueryDSL 장점?
-> JPQL과 달리 컴파일 시점에 오류를 잡을 수 있어 안정성이 높음.
->동적 쿼리를 가독성 있게 작성가능

QueryDSL. 언제써야하죠?
->조건이 많은 조회 로직이나 검색 기능에

QueryDSL. 왜썼죠?
->공휴일 조회 기능을 만들었을떄, 연도와 국가 코드가 optional한 조회 조건이어서 where 절이 동적으로 변하는 구조였고,
조건과 정렬이 늘어날 가능성을 고려해 JPQL 문자열 방식보다 조건 확장과 유지보수에 유리한 QueryDSL을 선택했습니다.”
(구체적으로 어디가 동적이었나요?)
->“연도와 국가 코드가 optional이라
null일 경우 조건에서 자동 제외되도록
where 조건을 분리해서 구성했습니다.”
(JPQL로도 가능하지 않나요?)
->“가능하지만 문자열 기반이라
조건이 늘어날수록 가독성과 유지보수가 떨어져
QueryDSL을 선택했습니다.”

타입안전(Type-safe) 뜻
->컴파일 시점(실행전에)에 오류를 잡아준다

QueryDSL은 왜 타입안전(Type-safe)?
-> JPQL은 문자열 기반이라 런타임 오류 위험이 있는데,
QueryDSL은 Q 클래스를 통해 필드와 타입을 컴파일 타임에 검증해서
타입 안전한 쿼리를 작성할 수 있습니다.”
------------------------------------------------
외부 API가 뭐죠?
-> 내가 만든 서버가 아닌 다른회사·서비스가 제공하는 기능·데이터를 HTTP요청으로 사용하는것
-> 예시: 공휴일 / 결제(카카오페이 등) / 로그인(카카오 소셜로그인) / 지도(카카오맵) API

외부 API 왜 썼죠? 왜 쓰죠?
->외부API사용경험 필요해서
-> 직접 구현하기 어려운 기능을 신뢰성 있게 재사용
최신 데이터(결제 상태, 공휴일 등)를 외부에서 제공받기 위함

외부API사용시 백엔드로서 생각(걱정, 고려)해볼점
->네트워크 지연·실패 가능성 있음
->타임아웃, 재시도, 예외 처리 필요
동기 호출 시 성능 영향 → @Async, 캐싱 등으로 보완
{
타임아웃: 외부 API가 응답을 안 주면 스레드가 계속 대기 → 서버 장애 / 몇초까지 기다리고 신호안오면 실패처리 / 지연대응
재시도: 몇초있다가 몇번만 재시도 / 무한x / 실패대응
예외처리: 캐시데이터 사용 / 현재사용불가 응답 / 기본값 반환 / 장애전파 차단
  (캐시는 단순한 성능 최적화 수단이 아니라,
  **외부 의존성 장애 시에도 서비스를 유지하기 위한 회복 전략(fallback)**으로 사용했습니다.)
  (하루나 한시간정도 데이터가 캐시에 남아있고, 일정시간 재사용 하는것
}

본인이 외부API사용하며 그런 단점에 대비한것이 있는가?
->외부 API 지연이 사용자 응답에 영향 주지 않도록 최근데이터 응답후, @Async를 써서 비동기 백그라운드 upsert 처리 / 응답지연회피

------------------------------------------------
Builder패턴이 뭐죠?
->복잡한 생성자를 안전하고 가독성 좋게 만들기 위한 생성 패턴
->생성자 파라미터가 많을 때 / 객체를 불변(immutable)하게 만들고 싶을 때 사용

builder왜썼음?
->“엔티티 필드가 많아서 생성자 파라미터 가독성이 떨어졌고,
필드 누락이나 순서 실수를 방지하기 위해 builder 패턴을 사용했습니다.”


