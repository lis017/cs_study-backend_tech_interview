직렬화(Serialization)
→ 객체를 네트워크/응답용 형태(JSON, XML 등)로 변환하는 과정

직렬화 문제란
->엔티티를 JSON으로 바꾸는 과정에서 JPA 내부 구조 때문에 에러·무한 참조·성능 문제가 발생하는 것을 말합니다.
//Spring API 기준:자바 객체 → Jackson → JSON

직접겪은 직렬화문제 경험및 해결경험
-> Holiday @Entity의 @ManyToOne필드 country;는 프록시객첸데, 컨트롤러에서 JSON변환시(고객 주려면)
LazyInitializationException(세션종료) OR 프록시 내부구조 노출 위험.
->(성능문제)JSON 변환 중 연관 엔티티 접근 -> Lazy 로딩이 의도치 않게 연쇄 실행-> N+1 폭발
해결-> DTO로 변환해서 반환.
-------------
JVM(자바 버츄얼 머신)
-> 자바 프로그램을 실행해주는 가상컴퓨터

JDK>JRE>JVM
이렇게 포함돼있음

JVM튜닝 목적
->GC횟수. 시간 줄여서 -> 응답시간 안정회
튜닝의 진짜 목적은:
->쓸데없이 오래 살아남는 객체를 만들지 말자”

heap구조
Heap
 ├─ Young Generation
 │   ├─ Eden
 │   ├─ Survivor S0
 │   └─ Survivor S1
 └─ Old Generation

heap
->객체 태어나고 죽는곳
->Heap = 스레드 간 공유 메모리
그래서:
동시성 이슈 가능
객체 많으면 GC 부담 증가

객체 흐름
객체 생성 → Eden
GC 시 살아있으면 → Survivor
오래 살아남으면 → Old Gen
Old Gen 가득 차면 → Full GC (끔찍함)

metaspace
->클래스정보. 리플렉션정보 프록시클래스
------------------------------
extends, implemetns 각각 뭐죠?
->extends는 “상속(물려받기)”, implements는 “구현(약속을 지키기)”입니다.
->interface는 implements로 구현하고, interface를 조합할 땐 extends를 사용합니다.
->한 줄 요약
extends: 이미 있는 기능을 물려받는다
implements: 정해진 메서드를 반드시 구현한다
ex) repocustom을 repository는 extends(jpa랑 조합해서)
                  impl은 implements(직접 구현해야해서)
->extends(상속)은 클래스끼리. 인터페이스끼리 가능.
섞어서는 안됨
->implements는 인터페이스상위, 클래스하위만 가능함.
