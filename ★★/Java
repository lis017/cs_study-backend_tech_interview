gc log 어찌봤는가
-> G1 GC 로그를 활성화하여 Pause Full, Pause Young 로그와 Heap Before/After 수치를 직접 분석 → Young GC 후 Heap이 정상 회수되고 Full GC가 발생하지 않음을 확인하여 GC 병목을 배제
--------------
직렬화(Serialization)
→ 객체를 네트워크/응답용 형태(JSON, XML 등)로 변환하는 과정

직렬화 문제란
->엔티티를 JSON으로 바꾸는 과정에서 JPA 내부 구조 때문에 에러·무한 참조·성능 문제가 발생하는 것을 말합니다.
//Spring API 기준:자바 객체 → Jackson → JSON

직접겪은 직렬화문제 경험및 해결경험
-> Holiday @Entity의 @ManyToOne필드 country;는 프록시객첸데, 컨트롤러에서 JSON변환시(고객 주려면)
LazyInitializationException(세션종료) OR 프록시 내부구조 노출 위험.
->(성능문제)JSON 변환 중 연관 엔티티 접근 -> Lazy 로딩이 의도치 않게 연쇄 실행-> N+1 폭발
해결-> DTO로 변환해서 반환.
-------------
추상클래스 쓴 경험?
-> spring security쓸때, auth에 제공되는 정보를 추가하기위해
Detail클래스에 추상클래스User를 extends해서, 추가정보를 보도록 수정한 경험
-------------
Heap증가 없었다
-> 메모리 누수 없었다, 메모리가 young gc이후에 계속 커지지않았다.

JVM(자바 버츄얼 머신)
-> 자바 프로그램을 실행해주는 가상컴퓨터

JDK>JRE>JVM
이렇게 포함돼있음

JVM튜닝 목적
->GC횟수. 시간 줄여서 -> 응답시간 안정회
튜닝의 진짜 목적은:
->쓸데없이 오래 살아남는 객체를 만들지 말자”
->객체를 빨리 죽게 만들자 (Young에서)

문제점
->캐시에 넣어놓고 사실 안 씀
세션에 큰 객체 저장
트랜잭션 오래 잡고 엔티티 들고 있음
이게 다 Old를 더럽히는 주범입니다
->이런걸 없애는게 jvm튜닝의 목적

heap구조
Heap
 ├─ Young Generation
 │   ├─ Eden
 │   ├─ Survivor S0
 │   └─ Survivor S1
 └─ Old Generation

heap
->객체 태어나고 죽는곳
->Heap = 스레드 간 공유 메모리
그래서:
동시성 이슈 가능
객체 많으면 GC 부담 증가

객체 흐름
객체 생성 → Eden
GC 시 살아있으면 → Survivor
오래 살아남으면 → Old Gen
Old Gen 가득 차면 → Full GC (끔찍함)

metaspace
->클래스정보. 리플렉션정보 프록시클래스

gc개선후에도 문제or p99튐 등 생기면 뭐할거냐
->“GC 개선 후에도 P99가 튄다면, Full GC 발생 원인을 분석하고 힙과 메타영역, Young/Old 영역 균형 조정 등 JVM 튜닝과 함께 애플리케이션 메모리 구조를 최적화합니다.”

->스레드가 죽는게 아니라 대기하다가 스레드풀로 돌아감
Young gc든 full gc든

->“GC는 객체 단위로 동작해 스레드는 유지되지만, OOM이 발생하면 JVM 프로세스가 종료되기 때문에 결과적으로 모든 스레드가 함께 종료됩니다.

->-GC Root: 스택에 있는 “참조 변수 자체”, static 필드, 살아있는 스레드 등
->스택영역에 있는 참조변수
  -> 참조변수는 힙 객체의 주소를 담는변수


JVM메모리구조
->힙(객체)
->Metaspace(클래스, 메서드, 코드)
->Stack(스택)(지역변수등)
->pc레지스터(현재 실행중인 명령어 위치)
->네이티브 메서드 스택(c,c++ 코드 실행용)

-------------
Thread Safe 꼬리질문
->컨트롤러를 무상태로 유지하고 핵심 비즈니스 로직을 서비스 계층으로 분리하여
싱글톤 환경에서도 스레드 안전한 구조를 설계했습니다.

-> @configuration있는 클래스에서도 무상태유지(싱글톤이라)
------------------
예외타입분류o, 예외처리방식x
컴파일러가 예외처리를 강제하느냐 여부

->(간단)(이것만해도 충분느낌)
“Checked Exception은 컴파일 시 예외 처리를 강제하고,
Unchecked Exception은 런타임 예외로 강제하지 않습니다.”

Checked Exception
->실패가 정상 흐름의 일부
->“이건 호출자가 대응해야 한다”
-> 컴파일 시점에 강제 처리되는 예외
->Checked: 반드시 try-catch 또는 throws 필요
->예외가 컴파일때 나는건 아님. 런타임에남. 컴파일단계에서 강제처리 하는것뿐.

Unchecked Exception
->비즈니스/설계 오류로
->실패는 버그 / 상태 오류
->“이건 버그다. 흐름 중단하고 상위에서 정리”
-> 런타임에 발생하며 선택적으로 처리하는 예외입니다.
->스프링 실무 거의 전부 Unchecked(외부 I/O한정 checked사용)
주의점
-> 트랜잭션시 unchecked는 롤백함. checked는 롤백안함.
------------------------------
extends, implemetns 각각 뭐죠?
->extends는 “상속(물려받기)”, implements는 “구현(약속을 지키기)”입니다.
->interface는 implements로 구현하고, interface를 조합할 땐 extends를 사용합니다.
->한 줄 요약
extends: 이미 있는 기능을 물려받는다
implements: 정해진 메서드를 반드시 구현한다
ex) repocustom을 repository는 extends(jpa랑 조합해서)
                  impl은 implements(직접 구현해야해서)
->extends(상속)은 클래스끼리. 인터페이스끼리 가능.
섞어서는 안됨
->implements는 인터페이스상위, 클래스하위만 가능함.
