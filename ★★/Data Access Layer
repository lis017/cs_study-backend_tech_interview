delete를 mybatis로 바꾼이유(JPA Delete문제점)
->1️⃣ JPA Delete 문제점
엔티티를 영속성 컨텍스트에 올림
더티체킹 관리
1건씩 delete 수행 가능성 있음
flush 시점 관리 필요
특히 조건 삭제:
deleteByYearAndCountryCode(...)
→ 내부적으로 select 후 delete 수행 가능
→ 영속성 컨텍스트 관리 비용 발생
2️⃣ MyBatis Delete 장점
(DB 직접 제어)
바로 SQL 실행
영속성 컨텍스트 없음
더티체킹 없음
flush 개념 없음
메모리 사용 적음
--------------
QueryDSL에서 count문 분리 안하면 뭐가 안좋은데?
->불필요한 join하게됨(자동이라)
->불필요한 order by
->join때매 인덱스 못타고 풀스캔
------------
fetch join + 페이징 문제점
->row 뻥튀기로 인해 
사용자의 entity 기준 페이징시 row에 기준이 적용되어
원하지 않는 결과가 나옴.
->페이징 전에 join 결과가 확장됨 → 메모리 낭비
->count 쿼리에도 join 포함 → 불필요한 join + full scan 가능성

(1,2)해결법
->조회시. DTO projection
->수정시. ID조회 후 IN조회 + fetch join
(3)해결법
-> count쿼리 분리(@Query쓰기)
(전체)해결법(내 방법)
-> fetch join배제후 count문 분리
-> content문과 count문을 queryDSL로 각각 만듬
-------------
MyBatis왜썼니
->“대량 delete는 JPA 영속성 컨텍스트와 동기화 이슈가 있어 관리 비용이 발생하기 때문에, SQL을 직접 제어할 수 있는 MyBatis가 더 안전하고 예측 가능했습니다.”
->JPQL로 지우면 DB날려도 Entity엔 남아있는 데이터불일치 발생.(Bulk)(영속성 컨텍스트 무시하고 진행)
->더티체킹 안함

✅ MyBatis를 Find/Delete에 쓴 이유
조회는 동적 필터 조합이 많아 QueryDSL이 유리
대량 delete는 JPA bulk 연산 시 영속성 컨텍스트 동기화 문제 존재
flush / clear 관리 포인트 발생
MyBatis는 SQL 직접 실행 → 예측 가능
대량 처리 시 더티체킹 부담 없음
실행 흐름이 단순하고 디버깅 용이
