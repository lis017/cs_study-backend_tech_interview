lazy는 실사용 전에는 프록시객체가 그 위치를 차지하고있다.

LAZY vs EAGER 차이
연관관계에서
참조하고 쓸때 로딩 vs 즉시로딩
--------------
fetch join은 join이라기보단 JPA에서쓰는 연관entity 로딩전략이다.
----------
정합성
-> 시스템 내부 일괸성을 따르고 규칙을 지키는가
->항상 옳은결과 X

무결성
->항상 데이터가 옳은 상태인가.
훼손되거나 잘못되지 않았는가.
---------------
Many to One과 One to Many에 대하여
-> 둘다 Many테이블에서 One에 대한 FK를 저장함
-> ✅ 매니투원 (Many → One)
→ 여러 데이터가 하나를 참조
✅ 원투매니 (One → Many)
→ 하나가 여러 데이터를 소유
->to뒤에 있는게 해당필드.
-> @OnetoMany면
해당필드가 많다는거니 보통 컬렉션타입이어야함

-> 엔티티간 관계에 대한것. 필드는 상관x
---------------
db의 참조는 프로그래밍 참조랑 다름
->같은값 저장 + 무결성 강제 구조

DB는 객체참조개념이 없음.
->값 복사 + 무결성 보장

참조무결성 존재이유
->“참조 무결성은 개발자 실수, 동시성, 배치 작업 등으로 인해 ‘존재하지 않는 대상’을 가리키는 데이터가 DB에 쌓이는 걸 막기 위해 필요합니다.”

FK는 주소저장이 아니라 값을 복사하는것.
---------------
Join하는 주체는 
-> queryDSL, JPQL, 메서드쿼리등이다.
-> 작업을 시키면 알아서 내부적으로 조인함.필요할때.
---------------
MyBatis가 가로챔 (프록시)의 원리
-> MyBatis Mapper 가로채기는 Filter·Interceptor·AOP가 아니라, JDK 동적 프록시 기반의 프록시 객체 생성입니다.
👉 “MyBatis는 Mapper 인터페이스를 JDK Dynamic Proxy로 구현하고, 메서드 호출을 내부 InvocationHandler에서 가로챕니다.”
-----------
fetch join 생각할점
-> 쿼리 줄어서 성능향상
-> 막쓰면 메모리폭탄