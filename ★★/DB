lazy는 실사용 전에는 프록시객체가 그 위치를 차지하고있다.

LAZY vs EAGER 차이
연관관계에서
참조하고 쓸때 로딩 vs 즉시로딩
---------------
Many to One과 One to Many에 대하여
-> 둘다 Many테이블에서 One에 대한 FK를 저장함
-> ✅ 매니투원 (Many → One)
→ 여러 데이터가 하나를 참조
✅ 원투매니 (One → Many)
→ 하나가 여러 데이터를 소유
->to뒤에 있는게 해당필드.
-> @OnetoMany면
해당필드가 많다는거니 보통 컬렉션타입이어야함

-> 엔티티간 관계에 대한것. 필드는 상관x
---------------
db의 참조는 프로그래밍 참조랑 다름
->같은값 저장 + 무결성 강제 구조

DB는 객체참조개념이 없음.
->값 복사 + 무결성 보장

FK는 주소저장이 아니라 값을 복사하는것.
---------------
MyBatis가 가로챔 (프록시)의 원리
-> MyBatis Mapper 가로채기는 Filter·Interceptor·AOP가 아니라, JDK 동적 프록시 기반의 프록시 객체 생성입니다.
👉 “MyBatis는 Mapper 인터페이스를 JDK Dynamic Proxy로 구현하고, 메서드 호출을 내부 InvocationHandler에서 가로챕니다.”
-----------
fetch join 생각할점
-> 쿼리 줄어서 성능향상
-> 막쓰면 메모리폭탄