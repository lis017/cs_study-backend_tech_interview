ACID
->DB가 “중간에 망가져도 데이터는 안전하다”를 보장하는 규칙
->ACID는 트랜잭션의 신뢰성을 보장하는 4가지 핵심 속성입니다.
->Atomicity
원자성
전부 성공 or 전부 실패
-Consistency
일관성
규칙은 항상 유지
-Isolation
격리성
트랜잭션끼리 간섭 X
-Durability
지속성
커밋되면 안 날아감
-----------
어떻게 쿼리 성능문제를 파악하는가(쿼리 성능문제 발생시)
->쿼리 성능 문제가 발생하면 먼저 실행계획을 확인하여 인덱스 사용 여부와 조인 방식을 점검합니다.
---------------
N+1이 무엇인가
->N+1은 1번 조회 후, 연관 객체를 접근할 때 N번의 추가 SELECT가 발생하는 현상입니다.

왜 발생하는가
->LAZY라서
✔ 객체 접근 시점에 DB 조회하기 때문

fetch join 장점
-> 원래 lazy때매 n번 select쿼리발생.
but. 얘는 join 1개 쿼리로 다 가져옴.
->(언제쓰냐)조회 후 수정 필요

DTO projection 장점
->필요한 컬럼만 조회
👉 엔티티 생성 안 함
👉 영속성 컨텍스트 안 올림
👉 변경 감지 안 함
 쿼리 자체를 줄입니다
-> join으로 가져오는 단 1개의 쿼리로 진행됨.
->(언제쓰냐) 화면 출력용 읽기 전용
-----------
동시성 제어 어떡할거냐.
-"먼저 트랜잭션 범위를 최소화해서 경합 자체를 줄입니다.
중복 데이터 문제는 DB unique 제약으로 1차 방어하고,
충돌 빈도가 낮으면 낙관락, 실제 충돌이 자주 발생하면 비관락을 사용합니다.
Isolation Level은 기본적으로 Read Committed를 유지하고,
팬텀 리드까지 막아야 하는 도메인에서만 Serializable을 검토합니다."
------------
(동시성 개선중 하나)
낙관적 락
->수정 시 version을 비교해 충돌을 감지합니다.
DB를 미리 잠그지 않아 성능이 좋습니다.
충돌 발생 시 예외를 던지고 재시도합니다.

비관적 락
-> 충돌이 날 것이라고 가정하고, 데이터를 미리 잠가버리는 방식이다.
->조회할 때부터 미리 잠그는 것

공통 장점
->데이터 덮어쓰기(Lost Update)를 방지할 수 있습니다.

이 락들 언제 쓰냐
->“동시에 같은 row를 수정하는 일이 자주 발생하느냐?”
---------------
Isolation Level(트랜잭션 격리수준)
->트랜잭션 간 데이터 간섭을 어느 수준까지 허용할지 정하는 격리 수준이며, 동시성과 정합성의 트레이드오프를 결정하는 핵심 설정입니다.
->격리 수준 ↑ = 정합성 ↑ = 성능

종류는?
->Read Uncommitted 거의 안씀 (Dirty Read 가능)(롤백될 데이터 읽음)
Read Committed Dirty Read 방지
Repeatable Read Lost Update 방지
Serializable 완전 직렬화,(범위락)
------------
Redis 분산락
->여러 서버 인스턴스에서 동일 자원에 동시에 접근하지 못하도록, Redis를 이용해 전역적으로 Lock을 거는 방식입니다.

Redisson
-> Redis를 자바에서 쉽게 사용하도록 만든 클라이언트 라이브러리이며, 분산락·세마포어·캐시 등 고급 동시성 기능을 제공합니다.

"멀티 인스턴스 환경에서 동일 자원 경쟁이 발생하면 Redis 분산락을 고려합니다. 직접 구현은 위험하므로 Redisson 같은 검증된 라이브러리를 사용합니다."
-------------
운영 중 테이블 구조를 변경해본 경험 있나요?
->경험은 없지만
실무에서는 DB 스키마 변경 시 마이그레이션 도구나 스크립트를 통해 개발·운영 환경에 동일하게 반영합니다.
-------------
SQL Injection: 
->입력값으로 SQL을 조작하는 해킹 기법

방지법
->preparedstatement
->입력 그대로 sql사용이 아닌 문자열로 변환해서 받는것
-----------
read only Transactional
->스냅샷 안만듬
더티체킹 안함
->Lazy때문에 사용시 용이
-------------
lazy는 실사용 전에는 프록시객체가 그 위치를 차지하고있다.

LAZY vs EAGER 차이
연관관계에서
참조하고 쓸때 로딩 vs 즉시로딩
--------------
fetch join은 join이라기보단 JPA에서쓰는 연관entity 로딩전략이다.
---------------
Many to One과 One to Many에 대하여
-> 둘다 Many테이블에서 One에 대한 FK를 저장함
-> ✅ 매니투원 (Many → One)
→ 여러 데이터가 하나를 참조
✅ 원투매니 (One → Many)
→ 하나가 여러 데이터를 소유
->to뒤에 있는게 해당필드.
-> @OnetoMany면
해당필드가 많다는거니 보통 컬렉션타입이어야함

-> 엔티티간 관계에 대한것. 필드는 상관x
---------------
fk연결된 상태에서 부모가삭제되면 자식은?
->ON DELETE설정에 따라 달라짐
->RESTRICT - 자식 1개라도 있으면 삭제불가(기본)(실무)
CASCADE- 부모자식 연쇄삭제
SET NULL- 자식 FK컬럼만 NULL처리

“보통은 RESTRICT를 기본으로 두고,
생명주기가 완전히 종속된 경우에만 CASCADE를 사용하며,
관계는 끊되 이력을 남겨야 할 경우 SET NULL을 사용합니다.”
---------------
db의 참조는 프로그래밍 참조랑 다름
->같은값 저장 + 무결성 강제 구조

DB는 객체참조개념이 없음.
->값 복사 + 무결성 보장

참조무결성 존재이유
->“참조 무결성은 개발자 실수, 동시성, 배치 작업 등으로 인해 ‘존재하지 않는 대상’을 가리키는 데이터가 DB에 쌓이는 걸 막기 위해 필요합니다.”

FK는 주소저장이 아니라 값을 복사하는것.
---------------
Join하는 주체는 
-> queryDSL, JPQL, 메서드쿼리등이다.
-> 작업을 시키면 알아서 내부적으로 조인함.필요할때.
---------------
MyBatis가 가로챔 (프록시)의 원리
-> MyBatis Mapper 가로채기는 Filter·Interceptor·AOP가 아니라, JDK 동적 프록시 기반의 프록시 객체 생성입니다.
👉 “MyBatis는 Mapper 인터페이스를 JDK Dynamic Proxy로 구현하고, 메서드 호출을 내부 InvocationHandler에서 가로챕니다.”
------------
팬텀 리드
-> 같은 조건으로 두 번 조회했는데, 중간에 다른 트랜잭션이 INSERT/DELETE 해서 결과 행 수가 달라지는 현상입니다.
-----------
fetch join 생각할점
-> 쿼리 줄어서 성능향상
-> 막쓰면 메모리폭탄
-----------
정규화

정규형
->“좋은 테이블 구조 단계”
1정규형 = 1단계로 정리된 상태 = 한칸에 한 값만 
2정규형 = 2단계까지 정리된 상태
3정규형 = 3단계까지 정리된 상태 = 이행적 종속제거

정규화 1 2 3 정리
->1정규화는 원자값 보장,
2정규화는 부분 종속 제거,
3정규화는 이행적 종속 제거입니다.


 왜 정규화를 하나요?
데이터 중복을 줄이고 삽입·수정·삭제 이상을 방지하기 위해 합니다.

 정규화 단점은?
테이블이 분리되면서 JOIN이 증가하고 조회 성능이 저하될 수 있습니다.

③ 비정규화는 언제 하나요?
조회 성능이 중요하고 JOIN 비용이 클 때 일부 중복을 허용합니다.

어떤것들이 Anomaly(이상)이죠?
✔ 삽입 이상
공휴일 없으면 Country 저장 못하는 상황
✔ 수정 이상
Korea 이름 바꾸려면 여러 행 다 수정해야 함
✔ 삭제 이상
마지막 공휴일 삭제하면 국가 정보도 사라짐

//PK → A → B
B가 PK에 직접 의존하는 게 아니라
A를 통해 의존하는 구조
이걸 이행적 종속이라고 합니다.
------------
Oracle은 안정성과 대용량 처리에 강한 엔터프라이즈 DB