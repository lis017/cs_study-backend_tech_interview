JVM의 구조와 Java의 실행방식을 설명해주세요.
-> JVM의 역할은 자바 애플리케이션을 클래스 로더를 통해 읽어 자바 API와 함께 실행하는 것입니다.
-> JVM의 구조는 Class Loader, Execution engine, Runtime Data Area, JNI, Native Method Library로
    이루어져 있습니다.
-> Java의 실행방식
  자바 컴파일러(javac)가 자바 소스코드(.java)를 읽어 자바 바이트코드(.class)로 변환시킵니다.
  Class Loader를 통해 class 파일들을 JVM으로 로딩합니다.
  로딩된 class파일들은 Execution engine을 통해 해석됩니다.
  해석된 바이트코드는 Runtime Data Areas 에 배치되어 실질적인 수행이 이루어집니다.
//복습
//복습
    

GC가 무엇인지, 필요한 이유는 무엇인지, 동작방식에 대해 설명해주세요.
-> GC는 힙 영역에서 사용하지 않는 객체들을 제거하는 작업을 총칭합니다.
-> 필요한 이유: 자바는 개발자가 메모리를 직접 해제해줄 수 없는 언어이기 때문입니다.
-> 동작 방식은, GC는 Minor GC, Major GC로 구분할 수 있습니다. Minor GC는 young 영역에서,
    Major GC는 old 영역에서 일어난다고 정의합니다.
-> Minor GC는 Eden 영역이 가득 참에서 부터 시작됩니다.
    Eden 영역에서 참조가 남아있는 객체를 mark하고 survivor 영역으로 복사합니다. 
    그리고 Eden 영역을 비웁니다. Survivor 영역도 가득차면 같은 방식으로 
    다른 Survivor 영역에 복사하고 비웁니다. 이를 반복하다 보면 계속 해서 살아남는 객체는
    old 영역으로 이동하게 됩니다.
-> Major GC는 old 영역에서 일어납니다. 위와 반대로 삭제되어야 하는 객체를 mark합니다.
    그리고 지웁(sweep)니다.
//복습
//복습
//복습

컬렉션 프레임워크에 대해서 설명해주세요.
->  객체, 데이터들을 효율적으로 관리 할 수 있는 자료구조들이 있는 라이브러리
-> List, Set은 Collection 인터페이스을 상속받지만, Map 인터페이스는 구조상의 차이로 별도로 정의합니다.
//복습
//복습

제네릭에 대해서 설명해주세요.
->  컴파일 과정에서 타입체크를 해주는 기능으로 객체의 타입 안정성을 높이고 형변환의 번거로움을 줄여줌
//복습
//복습

애노테이션에 대해서 설명해주세요.
-> 애노테이션은 인터페이스를 기반으로 한 문법으로 주석처럼 코드에 달아 클래스에 특별한 의미를 부여하거나 기능을 주입할 수 있습니다.
//복습

오버라이딩과 오버로딩이 무엇이며 어떤 차이가 있을까요?
-> 오버라이딩은 상위 클래스의 메소드를 재정의 하는 것
-> 오버로딩은 같은 클래스 내에서 동일한 메소드 이름을 가지지만, 매개변수의 타입, 개수가 다르게 구현할 수 있는 것을 의미
    ,오버라이딩 될 수 있습니다.
-> 추가로 `@Override`를 써야하는 이유:
    이 애노테이션은 컴파일 타임에 오버라이딩에 대한 안정성을 부여해주기 때문에 반드시 써주는 것이 좋습니다.
    //복습

인터페이스와 추상클래스의 차이점에 대해 설명해주세요.
-> 인터페이스는 구현 객체가 같은 동작을 한다는 것을 보장하기 위해 사용합니다. 다중 상속이 가능합니다. 
    인터페이스를 구현하는 집합간에는 관계가 없을 수 있습니다.
-> 추상클래스는 객체의 추상적인 상위 개념으로 공통된 개념을 표현할 때 사용합니다. 단일 상속만 가능합니다.
    추상클래스를 상속하는 집합간에는 연관관계가 있습니다.
    //복습 //복습

클래스는 무엇이고 객체는 무엇인가요?
-> 클래스는 객체를 정의하는 설계도
-> 객체는 인스턴스들을 통칭하는 용도
    //복습 //복습

정적(static)이란 무엇인가요?
-> Static(정적)은 프로그램이 시작되는 시점에 클래스 로더가 클래스를 해석하여
    메소드 영역 혹은 힙 영역에 클래스 메타 데이터 및 정적 변수 등을 적재한다.
   //복습 
    //복습
    //복습

자바의 원시타입들은 무엇이 있으며 각각 몇 바이트를 차지하나요?
-> boolean(1), char(2), byte(1), short(2), int(4), long(8), float(4), double(8)
    //복습
//복습

접근 제어자의 종류와 이에 대해 설명해주세요.
-> private, default, protected, public이 있습니다. private은 해당 클래스 내에서만 접근 가능하고, default는 해당 패키지, 
    protected는 상속한 클래스, public은 전체 영역에서 접근 가능합니다. 
-> 접근 제어자를 사용하는 이유는 외부에 보여주고 싶은 정보들을 선택적으로 제공하기 위함이고, 캡슐화와 통하는 면이 있습니다.
    //복습
//복습

객체지향에 대해서 설명해주세요.
-> 객체지향을 정의하면, 의존성 관리입니다.
-> 의존성을 관리함으로써 변경 영향을 최소화하고 독립적인 개발이 가능해지며 독립적인 배포가 가능해집니다.
    //복습

SOLID(객체지향 5대원칙)에 대해서 설명해주세요.
-> S는 한 클래스의 하나의 책임만 가져야 함
-> O는 확장에는 열려 있으나 변경에는 닫혀 있어야 하며, 다형성을 활용해야 함
-> L은 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 함
-> I는 클라이언트는 사용하지 않는 메서드에 의존 관계를 맺으면 안됨 
-> D는 추상적인 것은 자신보다 구체적인 것에 의존하지 않고, 변화하기 쉬운 것에 의존해서는 안됨
    
동일성(identity)와 동등성(equality)에 대해 설명해주세요. (equals(), ==)
-> 동일성은 객체의 주소를 비교하는 것이고, 동등성은 객체의 같음을 비교하는 것
    //복습

원시타입과 참조타입의 차이에 대해 설명해주세요.
-> 원시타입은 Java에서 단 8개 밖에 존재하지 않는 타입입니다. 나머지는 모두 참조타입.
-> 원시타입은 항상 값이 존재해야 함. 반면, Object(참조) 타입은 null 포인터를 가질 수 있습니다.
    그리고 멤버변수가 초기화될 때, 원시타입은 기본값을 가지지만, 참조타입은 null 포인터를 가지는 차이도 있습니다.
    //복습
    
String, StringBuilder, StringBuffer 각각의 차이에 대해 설명해주세요.
-> String은 불변입니다. StringBuilder와 StringBuffer는 이런 String의 특징때문에 사용하는 가변타입이라고 볼 수 있습니다.
-> StringBuilder와 StringBuffer는 Thread-safe 여부의 차이가 있습니다. StringBuilder는 Thread-safe하지 않습니다.
    따라서 Multi-Thread 환경에서 사용할 때는 StringBuffer를 사용합니다.
    //복습

Checked Exception과 Unchecked Exception에 대해 설명해주세요. 스프링 트랜잭션 추상화에서 rollback 대상은 무엇일까요?
-> 둘의 차이는 RuntimeException을 상속하는가의 여부에 따라 다릅니다. RuntimeException을 상속하면 UncheckedException이 됩니다. 
    스프링 트랜잭션 추상화에서 rollback 대상은 바로 UncheckedException입니다.
    //복습

try-with-resource에 대해서 설명해주세요.
-> 자바 버전 7에 도입된 문법
-> try() 안에 사용할 리소스 객체를 명시적으로 선언하여 사용하면, JVM에서 자동으로 자원을 반납해주는 기능
       //복습

강한 결합과 느슨한 결합이 무엇인지 설명해주세요.
-> 어떤 모듈이 다른 모듈에 너무 자세한 부분(구현 세부사항)까지 알고 있을 경우에 강한 결합도를 가진다고 합니다.
-> 어떤 모듈이 다른 모듈에 대해 필요한 정보(인터페이스로 추상화된 고수준 정책)만 알고 있다면 두 모듈은 낮은 결합도를 가진다고 합니다.
-> 강한 결합도는 반드시 지양해함, 적절이 좋음
       //복습

직렬화와 역직렬화에 대해서 설명해주세요.
-> 직렬화란 자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록
       바이트 형태로 데이터 변환하는 기술
-> 역직렬화란 바이트로 변환된 데이터를 다시 변환하는 기술
-> 직렬화 장점: 시스템이 종료되더라도 없어지지 않는 장점을 가지며 영속화된 데이터이기 때문에 네트워크로 전송이 가능합니다.
       //복습

자바의 동시성 이슈(공유자원 접근)에 대해 설명해주세요.
-> 여러 스레드가 동시에 하나의 자원을 공유하고 있기 때문에 같은 자원을 두고 경쟁상태(raceCondition) 같은 문제가 발생하는 것
       //복습

Mutable 객체와 Immutable 객체의 차이점에 대해 설명해주세요.
-> Mutable 객체는 변경 가능 객체이고, Immutable 객체는 불변 객체
-> Mutable 객체는 도메인 개체로 사용됩니다. 
    Mutable 객체의 변경 메서드는 Command method라고도 부르며, 리턴 타입을 void 로 정의합니다.
-> Immutable 객체는 값 객체, 서비스 객체 등에 사용됩니다.
    //복습

자바에서 null을 안전하게 다루는 방법에 대해 설명해주세요.
-> 공개 메서드가 아닌 곳에는 assert를 사용하여 null을 방어할 수 있다. 
-> Optional을 사용해 리턴 타입에서 null을 반환하지 않도록 방어할 수 있다.
    등이 있습니다.
    //복습

JDK와 JRE의 차이점을 설명하세요.
-> JDK는 Java Development KIT의 약자로 개발하는데 사용되는 도구이며 JRE를 포함하고 있으며
JRE는 Java Runtime Environment의 약자로 자바로 만들어진 프로그램을 실행시키는데 필요한 도구가
들어있는 차이가 있습니다.
//복습






    
    
    
