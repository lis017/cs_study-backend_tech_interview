1️⃣ 트랜잭션 + 격리수준 + MVCC (최상위 단골)
-트랜잭션 격리 수준(Transaction Isolation Levels)이란?
-> 트랜잭션 간 데이터 충돌을 어떻게 제어할지 결정하는 수준
-> 고립도와 성능의 트레이드오프
Read Uncommitted
Read Committed
Repeatable Read
Serializable
Read Committed는 커밋된 데이터만 조회 가능
Repeatable Read는 동일 트랜잭션 내 조회 일관성 보장
Serializable은 트랜잭션을 순차 실행한 것처럼 보이게 만드는 최고 격리 수준
왜 격리수준이 필요하죠?
-> 동시에 여러 트랜잭션이 실행될 때 Dirty Read, Non-Repeatable Read, Phantom Read 같은 문제가 발생하기 때문입니다.
왜 Serializable은 성능이 떨어지나요?
-> 범위 락을 사용하여 동시성을 크게 제한하기 때문입니다.
-MVCC란?
-> 여러 버전의 데이터를 유지해 락 없이 읽기 일관성을 보장하는 방식
-> 버전 기반 동시성 제어
-> Repeatable Read는 MVCC 기반
-> Undo log로 이전 버전 관리 (InnoDB)
왜 MVCC를 사용하나요?
-> 읽기 시 락을 최소화하여 동시성을 높이기 위해 사용합니다.
-> 읽기 작업이 쓰기 작업을 막지 않게 합니다.
MVCC면 X락이어도 Select 가능
-> 이전 버전을 읽습니다.
InnoDB는 MVCC 기반
-SELECT FOR UPDATE
-> 조회 시점부터 X락을 걸어 다른 트랜잭션의 수정을 방지
왜 그냥 UPDATE 안 하고 SELECT FOR UPDATE를 쓰나요?
-> 조회 후 비즈니스 로직을 처리한 뒤 업데이트할 때, 그 사이에 다른 트랜잭션이 값을 변경하는 것을 막기 위함입니다.
-Undo Log
-> 트랜잭션 롤백과 MVCC 구현을 위해 이전 버전 저장
Redo Log
-> 장애 발생 시 복구용
왜 Undo와 Redo를 분리하나요?
-> Undo는 롤백과 MVCC용,
-> Redo는 장애 복구와 Durability 보장을 위해 목적이 다르기 때문입니다.
-트랜잭션 flush 시점
-> 수정 시 Undo/Redo 로그 기록
-> commit 직전 디스크 flush
-> Durability 보장
트랜잭션 없이 쓰기 작업하면?
-> RDB는 자동으로 트랜잭션 처리
2️⃣ 인덱스 + B-Tree + B+Tree (매우 중요)
-B-Tree
-> 한 노드에 여러 키 저장
-> 디스크 I/O 최소화 목적
-> 트리 높이를 낮게 유지
-B+Tree (InnoDB 사용)
-> 실제 데이터는 리프 노드에만 저장
-> 중간 노드는 key만 저장
-> 리프 노드는 연결 리스트로 연결
-> 범위 조회에 유리
왜 B+Tree를 쓰나요?
-> 디스크 접근을 최소화하기 위해 fan-out이 큰 구조가 필요합니다.
-> 범위 조회가 많기 때문에 리프 노드 연결 구조가 유리합니다.
-인덱스 특징
-> 이진탐색이 아니라 B+Tree 탐색
-인덱스 단점
-> 쓰기 시 인덱스 갱신 오버헤드 발생
왜 인덱스가 쓰기에 불리하죠?
-> 데이터 삽입/삭제 시 정렬 구조를 유지해야 하기 때문입니다.
-Primary Index (InnoDB 기준)
-> 클러스터드 인덱스
-> 리프 노드에 실제 row 데이터 저장
-> 테이블 자체가 PK 기준 B+Tree
-Secondary Index
-> 리프 노드에 (인덱스컬럼 + PK) 저장
-> 조회 시 PK로 한 번 더 탐색
왜 Secondary는 2단계 조회인가요?
-> 리프 노드에 실제 데이터 대신 PK만 저장되어 있기 때문입니다.
-커버링 인덱스
-> 쿼리에 필요한 컬럼이 모두 인덱스에 포함
-> 추가 테이블 접근 없음
왜 빠르죠?
-> 클러스터드 인덱스를 다시 탐색하지 않기 때문입니다.
-인덱스 타는 조건
WHERE 인덱스 컬럼 사용
=, >, <, BETWEEN
LIKE 'abc%'
ORDER BY 인덱스 컬럼
복합 인덱스는 왼쪽부터
인덱스 안 타는 경우
LIKE '%abc'
함수 사용
컬럼 연산
타입 불일치
복합 인덱스에서 앞 컬럼 없이 뒤만 사용
왜 옵티마이저가 풀스캔을 선택하나요?
-> 데이터 분포와 비용 계산 결과, 전체의 30% 이상 조회 시 인덱스보다 풀스캔이 빠를 수 있기 때문입니다.
3️⃣ 제약조건 + 정규화 + 무결성
-DB 제약조건
-> 데이터 무결성을 유지하기 위한 규칙
PRIMARY KEY
FOREIGN KEY
UNIQUE
NOT NULL
CHECK
왜 DB에서 제약조건을 걸어야 하나요?
-> 애플리케이션 로직 오류와 상관없이 데이터 무결성을 강제하기 위해서입니다.
-정규화
-> 중복 제거
-> 무결성 유지
왜 정규화를 하나요?
-> 데이터 중복으로 인한 이상현상(삽입/삭제/갱신 이상)을 방지하기 위해서입니다.
4️⃣ JOIN + 쿼리
-JOIN
INNER JOIN
OUTER JOIN
CROSS JOIN
SELF JOIN
왜 JOIN이 느릴 수 있나요?
-> 인덱스 미사용, 대용량 테이블 조인 시 디스크 I/O 증가 때문입니다.
5️⃣ RDBMS vs NoSQL + CAP
-RDBMS
-> 관계 기반 저장
-> 무결성, 트랜잭션 강점
-NoSQL
-> 유연한 구조
-> 수평 확장 용이
왜 NoSQL은 수평 확장이 쉬운가요?
-> 조인 중심 구조가 아니고, 샤딩 구조에 최적화되어 있기 때문입니다.
-CAP 이론
-> Consistency, Availability, Partition tolerance
-> 분산 시스템은 3개 모두 만족 불가
Eventual Consistency
-> 결과적으로 언젠가는 일관성 보장
6️⃣ 검색 + Full Text + Elasticsearch
-Full Text Index
-> inverted index 기반
-> 랭킹 알고리즘 제공
왜 B+Tree보다 검색에 유리하죠?
-> 단어 단위 역색인 구조라 부분 검색과 랭킹 계산에 최적화되어 있기 때문입니다.
-Elasticsearch
-> 분산 검색 엔진
-> 대용량 텍스트 검색 특화
7️⃣ MyBatis + QueryDSL
-MyBatis
-> SQL을 직접 작성하는 SQL Mapper
-> 복잡한 쿼리 최적화에 유리
왜 실무에서 혼용하나요?
-> 단순 CRUD는 ORM이 빠르고, 복잡한 튜닝 쿼리는 MyBatis가 유리하기 때문입니다.
-QueryDSL
-> 타입 세이프한 쿼리 작성 라이브러리
-> 컴파일 타임 오류 검출
-> 동적 쿼리 작성 용이
왜 QueryDSL을 쓰나요?
-> 문자열 기반 JPQL은 런타임 오류가 발생할 수 있기 때문입니다
장점
-> 가독성+ 타입안전 + null은자동무시
주의점 개선 경험
->(null safe)delete시 조건없으면 전체삭제 -> where절 떼서 null이면 null. 아니면 해당 연도가 들어가도록
->페이징시 count분리 -> 불필요 jojn제거
null safe, null자동무시는 QueryDSL만 가능한가?
->다르것도 되지만 QueryDSL이 가장 간결.