우선순위 정렬 + 유사 개념 묶음) -------------------
1️⃣ 웹 통신 흐름 + HTTP + HTTPS(최상위 단골)
-웹 통신의 큰 흐름: https://www.google.com/⁠� 을 접속할 때 일어나는 일
->
브라우저가 URL을 파싱하여 HTTP Request Message를 생성하고 OS에 전송 요청을 합니다.
Domain으로 바로 요청할 수 없기 때문에 DNS Lookup을 수행합니다.
(브라우저 캐시 → OS 캐시 → hosts 파일 → DNS 서버 순)
IP를 얻으면 TCP 3way handshake로 연결을 수립합니다.
HTTPS라면 TLS Handshake를 진행하여 대칭키를 생성합니다.
HTTP 요청은 TCP 세그먼트 → IP 패킷 → 프레임으로 캡슐화되어 전송됩니다.
스위치 → 라우터 → ISP → 인터넷 백본망을 거쳐 서버에 도달합니다.
서버에서 역캡슐화 후 애플리케이션까지 전달됩니다.
서버가 응답을 생성하고 동일한 경로를 통해 클라이언트로 반환됩니다.
-HTTP와 HTTPS의 차이
-> HTTPS는 HTTP + TLS
-> 공개키는 대칭키를 안전하게 교환하기 위해 사용
-> 실제 데이터 암호화는 대칭키 사용
왜 대칭키를 쓰나요?
-> 공개키 암호화는 연산 비용이 크기 때문에 데이터 전체를 암호화하기엔 느립니다.
-> 그래서 공개키는 대칭키를 안전하게 교환하는 용도로만 사용하고, 실제 통신은 빠른 대칭키 암호화를 사용합니다.
-HTTPS와 TLS Handshake
-> 클라이언트와 서버가 암호화 방식과 대칭키를 협상하는 과정
-> 인증서를 통해 서버 신뢰성 검증
-> TLS 1.3이 최신
-HTTP 1.1 vs HTTP 2
-> HTTP/1.1은 요청-응답 순차 처리 (HOL Blocking 발생)
-> HTTP/2는 Multiplexing으로 동시에 여러 요청 처리
-> Header 압축 지원
왜 HTTP/2가 빠른가요?
-> 하나의 TCP 연결에서 여러 요청을 동시에 처리(Multiplexing)하기 때문에 대기 시간이 줄어듭니다.
-> Header 압축으로 불필요한 데이터 전송량을 줄입니다.
-> TCP 연결을 여러 개 맺지 않아도 되기 때문에 오버헤드가 감소합니다.
-HTTP 3는 무엇인가?
-> TCP가 아닌 QUIC(UDP 기반) 위에서 동작
-> TCP의 HOL Blocking 문제 해결
-HTTP 메서드와 역할
-> GET: 리소스 조회 (멱등)
-> POST: 리소스 생성
-> PUT: 전체 수정 또는 없으면 생성 (멱등)
-> PATCH: 부분 수정
-> DELETE: 리소스 삭제 (멱등)
-멱등성이란?
-> 동일 요청을 여러 번 보내도 결과가 같은 성질
-CORS란?
-> 브라우저의 Same Origin Policy 때문에 발생하는 보안 정책
-> 서버가 Access-Control-Allow-Origin 헤더로 허용
-> Preflight(OPTIONS) 요청 발생 가능
2️⃣ 인증 / 상태 관리
-쿠키와 세션의 차이
-> 쿠키는 클라이언트 저장
-> 세션은 서버 저장
-> 세션은 쿠키(Session ID)로 식별
-JWT란?
-> JSON Web Token
-> 서버가 상태를 저장하지 않는 Stateless 인증 방식
-> 토큰 탈취 시 위험
-Stateless란?
-> 서버가 클라이언트 상태를 저장하지 않는 것
-> 확장성에 유리
왜 Stateless가 확장성에 유리하죠?
-> 서버가 클라이언트 상태를 저장하지 않기 때문에, 어떤 서버로 요청이 가더라도 동일하게 처리할 수 있습니다.
-> 로드밸런서를 통해 서버를 쉽게 수평 확장할 수 있습니다.
-> 세션 공유나 동기화 비용이 발생하지 않습니다.
3️⃣ TCP / UDP / 연결 제어
-TCP와 UDP의 차이점
-> TCP는 연결지향형
-> 신뢰성 보장 (재전송, 흐름제어, 혼잡제어, 순서보장)
-> UDP는 비연결형, 신뢰성 보장 X, 빠름
-> TCP는 정확성이 중요한 서비스
-> UDP는 실시간성이 중요한 서비스
-TCP 3way handshake
-> 연결 수립
SYN → SYN+ACK → ACK
왜 TCP는 3way인가요?
-> 양쪽이 송수신이 가능한 상태인지 확인하기 위해 최소 3번의 메시지가 필요합니다.
-> 2번만 하면 서버의 응답 수신 여부를 보장할 수 없습니다.
-> 3단계를 통해 양방향 통신이 가능함을 확인합니다.
-TCP 4way handshake
-> 연결 해제
FIN → ACK → FIN → ACK
-Keep-Alive란?
-> 하나의 TCP 연결을 재사용하여 성능 향상
왜 Keep-Alive가 성능에 좋죠?
-> 매 요청마다 TCP 3way handshake를 수행하지 않아도 됩니다.
-> 연결 수립/해제 오버헤드가 줄어듭니다.
-> 네트워크 지연 시간이 감소합니다.
4️⃣ 네트워크 계층 구조
-OSI 7계층과 존재 이유
-> 네트워크 통신을 7단계로 표준화한 모델
-> 계층별 분리로 문제 파악이 용이
1계층: 물리
2계층: 데이터 링크
3계층: 네트워크
4계층: 전송
5계층: 세션
6계층: 표현
7계층: 응용
-TCP/IP 4계층
1계층: 네트워크 액세스
2계층: 인터넷
3계층: 전송
4계층: 응용
-> HTTP는 응용계층
-> TCP는 전송계층
-> IP는 인터넷 계층
-TCP/IP 5계층
1계층: 물리
2계층: 데이터링크
3계층: 네트워크
4계층: 전송
5계층: 응용
5️⃣ 서버 / 인프라
-웹 서버 소프트웨어(Apache, Nginx)는 어디서 동작하는가?
-> Application Layer (7계층)
-> TCP 위에서 동작
-웹 서버의 라우팅 기능은 몇 계층인가?
-> L4: 포트 기반
-> L7: HTTP URI 기반
-Load Balancer란?
-> 여러 서버로 트래픽을 분산
-> L4 / L7 방식 존재
-CDN이란?
-> 사용자와 가까운 서버에서 정적 리소스를 제공
-> 지연 감소 및 트래픽 분산