1️⃣ 웹 통신 흐름 + HTTP + HTTPS (최상위 단골)
🔹 웹 통신 흐름
브라우저가 URL을 파싱 → HTTP Request 생성 → DNS Lookup → TCP 3way → TLS Handshake → 캡슐화 → 서버 전달 → 응답 반환
❓ 왜 DNS가 먼저인가요?
→ TCP 연결은 IP 기반 통신이기 때문입니다.
도메인은 사람이 읽기 위한 이름이고, 실제 통신은 IP로 이루어지므로 먼저 IP를 알아야 연결 수립이 가능합니다.
🔹 HTTPS는 왜 대칭키를 쓰나요?
→ 공개키 암호화는 연산 비용이 매우 큽니다.
→ 실제 데이터 전체를 공개키로 암호화하면 성능이 크게 저하됩니다.
→ 그래서 공개키는 대칭키 교환용, 실제 데이터 암호화는 빠른 대칭키 방식을 사용합니다.
🔹 TLS Handshake
클라이언트와 서버가 암호화 알고리즘과 대칭키를 협상하는 과정
인증서로 서버 신뢰성 검증
❓ 왜 인증서가 필요한가요?
→ 공개키만 전달하면 중간자 공격(MITM) 위험이 있습니다.
→ 인증서는 공인된 CA가 서명하여 “이 서버가 진짜인지”를 보장합니다.
🔹 HTTP/2가 왜 빠른가요?
→ Multiplexing으로 하나의 TCP 연결에서 여러 요청 동시 처리
→ Header 압축
→ 연결 재사용
❓ 왜 Multiplexing이 중요한가요?
→ HTTP/1.1은 요청이 순차 처리되어 HOL Blocking 발생
→ HTTP/2는 병렬 처리로 대기 시간 감소
🔹 HTTP/3는 왜 QUIC(UDP)를 쓰나요?
→ TCP 기반에서는 패킷 하나 지연 시 전체 스트림 지연(HOL Blocking)
→ QUIC은 스트림 단위 독립 처리로 지연 최소화
2️⃣ 인증 / 상태 관리
🔹 Stateless란?
서버가 클라이언트 상태를 저장하지 않음
❓ 왜 Stateless가 확장성에 유리하죠?
→ 서버가 상태를 저장하지 않으므로
→ 어떤 서버가 요청을 받아도 동일 처리 가능
→ 세션 동기화 불필요
→ 수평 확장(Scale Out)에 유리
🔹 JWT는 왜 탈취 위험이 크죠?
→ 서버에 상태가 없기 때문에
→ 토큰이 유효한 동안은 서버가 강제로 무효화하기 어려움
→ 그래서 만료 시간 + Refresh 전략이 중요
3️⃣ TCP / UDP / 연결 제어
🔹 TCP 3way handshake
SYN → SYN+ACK → ACK
❓ 왜 TCP는 3way인가요?
→ 양쪽 모두 송수신 가능 상태인지 확인 필요
→ 2번이면 서버의 응답 수신 여부 보장 불가
→ 3단계로 양방향 연결 성립 확인
🔹 TCP는 왜 신뢰성을 보장하나요?
→ 재전송, 순서 보장, 흐름제어, 혼잡제어 메커니즘이 있기 때문
→ UDP는 이런 보장 없음
🔹 Keep-Alive는 왜 성능에 좋나요?
→ 매 요청마다 3way handshake 안 해도 됨
→ 연결 수립 오버헤드 감소
→ 네트워크 RTT 감소
4️⃣ 네트워크 계층 구조
🔹 OSI 7계층은 왜 존재하나요?
→ 네트워크 통신을 계층별로 분리해
→ 문제 발생 지점 파악을 쉽게 하기 위해
🔹 왜 HTTP는 7계층이고 TCP는 4계층인가요?
→ HTTP는 애플리케이션 레벨 프로토콜
→ TCP는 데이터 전달을 담당하는 전송 계층 프로토콜
→ 역할이 다르기 때문
5️⃣ 서버 / 인프라
🔹 Load Balancer는 왜 필요한가요?
→ 단일 서버 장애 시 전체 서비스 중단 방지
→ 트래픽 분산으로 부하 감소
→ 확장성 확보
🔹 CDN은 왜 빠른가요?
→ 사용자와 물리적으로 가까운 서버에서 응답
→ RTT 감소
→ 원본 서버 트래픽 감소